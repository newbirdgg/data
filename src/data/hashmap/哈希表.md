## 哈希表
* 哈希表充分体现了算法设计领域的经典思想：空间换时间
* 哈希表是时间和空间之间的平衡
* 哈希函数的设计是很重要的
* “键”通过哈希函数得到的“索引”分布越均匀越好
### 哈希函数的设计
* 整型：
    - 小范围的正整数直接使用
    - 小范围的负整数进行偏移 -100~100 -> 100~200
* 大整数：
    - 身份证号 -> 取模 比如：取后四位。等同于mod 10000（缺点：没有利用所有信息，容易冲突） 
    - 一个简单解决方法：模一个素数 
* 浮点型：
    - 在计算机中都是32位或者64位的二进制，只不过计算机解析成了浮点数    
    - 转成整型处理
* 字符串：
    - 转成整型处理
    - 166 = 1\*10^2+6\*10^1+6\*10^0
    - code = c\*26^3+o\*26^2+d\*26^1+e*26^0
    - code = c\*B^3+o\*B^2+d\*B^1+e*B^0
    - hash(code) = (c\*B^3+o\*B^2+d\*B^1+e*B^0) % M
    - hash(code) = ((((c*B)+o)*B+d)*B+e) % M 
    - hash(code) = ((((c%M)\*B+o)%M\*B+d)%M*B+e) % M 
```
 int hash = 0;
 for(int i = 0;i<s.length();i++){
    hash = (hash * B + s.charAt(i)) % M;
}
```   

### 哈希函数设计原则
1. 一致性：如果a==b，则hash(a)==hash(b)
2. 高效性：计算高效简便
3. 均匀性：哈希值均匀分布      

## hashcode和equals
* 如果要在hash表中存入自定义对象的键，那么必须要重写hashcode和equals
* 如果只重写hashcode不重写equals，那么new两个相同意义的对象，他们之间比较用的equals是Object默认的equals，比较的是对象的地址，是一定不相同的。
* 如果只重写equals不重写hashcode，那么他们在存入键的时候计算的hash索引下标是不同的，导致我把小明和他的成绩60这个Student存入key，发现成绩不对，再去存一个新的小明和他的成绩100，这时候hash表中就会出现两个小明，即使他俩是一样的只是成绩不同。
   